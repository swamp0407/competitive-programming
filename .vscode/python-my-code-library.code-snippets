{
    "rerooting": {
        "prefix": "Rerooting",
        "scope": "python",
        "body": [
            "import sys",
            "",
            "# https://atcoder.jp/contests/dp/submissions/22766939",
            "",
            "",
            "class Rerooting():",
            "    def __init__(self, n: int, decrement: int = 1):",
            "        \"\"\"nは頂点数 decrementはノードの番号が0-indexedの場合0でよい\"\"\"",
            "        self.n = n",
            "        self.adj = [[] for _ in range(n)]",
            "        self.root = None  # 一番最初に根とする頂点",
            "        self.decrement = decrement",
            "",
            "    def add_edge(self, u: int, v: int):",
            "        \"\"\"辺を追加する u,vは元々の値で良い\"\"\"",
            "        u -= self.decrement",
            "        v -= self.decrement",
            "        self.adj[u].append(v)",
            "        self.adj[v].append(u)",
            "",
            "    def rerooting(self, op, merge, e, root: int = 1) -> list:",
            "        \"\"\"",
            "        <概要>",
            "        1.rootを根としてまず一度木構造をbfsで求める 多くの場合rootは任意",
            "        2.自身の部分木のdpの値をdp1に、自身を含まない兄弟のdpの値のmergeをdp2に入れる",
            "          木構造が定まっていることからこれが効率的に求められる。 葉側からボトムアップに実行する",
            "        3.任意の頂点を新たに根にしたとき、部分木は",
            "          ①元の部分木 ②兄弟を親とした部分木 ③元の親を親とした(元の根の方向に伸びる)部分木の三つに分かれる。",
            "          ①はstep2のdp1であり、かつdp2はstep3において、②から②と③をmergeした値へと更新されているので",
            "          ②も③も分かっている。 根側からトップダウンに実行する(このことが上記の更新において重要)",
            "        計算量 O(|V|) (|Vは頂点数)",
            "        参照 https://qiita.com/keymoon/items/2a52f1b0fb7ef67fb89e",
            "        \"\"\"",
            "        # step1",
            "        root -= self.decrement",
            "        assert 0 <= root < self.n",
            "        self.root = root",
            "        self.parent = [-1]*self.n  # 親の番号を記録",
            "        self.order = [root]  # bfsの訪問順を記録 深さが広義単調増加している",
            "        stack = [root]",
            "        while stack:",
            "            from_node = stack.pop()",
            "            for to_node in self.adj[from_node]:",
            "                if to_node == self.parent[from_node]:",
            "                    continue",
            "                self.parent[to_node] = from_node",
            "                self.order.append(to_node)",
            "                stack.append(to_node)",
            "        # step2",
            "        dp1 = [e] * self.n",
            "        dp2 = [e] * self.n",
            "        for from_node in self.order[::-1]:",
            "            t = e",
            "            for to_node in self.adj[from_node]:",
            "                if self.parent[from_node] == to_node:",
            "                    continue",
            "                dp2[to_node] = t",
            "                t = merge(t, op(dp1[to_node], from_node, to_node))",
            "            t = e",
            "            for to_node in self.adj[from_node][::-1]:",
            "                if self.parent[from_node] == to_node:",
            "                    continue",
            "                dp2[to_node] = merge(t, dp2[to_node])",
            "                t = merge(t, op(dp1[to_node], from_node, to_node))",
            "            dp1[from_node] = t",
            "        # step3",
            "        for new_root in self.order[1:]:  # 元の根に関するdp1は既に求まっている",
            "            par = self.parent[new_root]",
            "            dp2[new_root] = op(merge(dp2[new_root], dp2[par]), new_root, par)",
            "            dp1[new_root] = merge(dp1[new_root], dp2[new_root])",
            "        return dp1",
            "",
            "",
            "def op(a, u, v):",
            "    # dpをmergeする前段階で実行する演算",
            "    # 例:最も遠い点までの距離を求める場合 return a+1",
            "    return a+1",
            "",
            "",
            "def merge(a, b):",
            "    # モノイドの性質を満たす演算を定義する それが全方位木DPをする条件",
            "    # 例:最も遠い点までの距離を求める場合 return max(a,b)",
            "    # return a*b % M",
            "    return max(a, b)",
            "",
            "# mergeの単位元",
            "# 例:最も遠い点までの距離を求める場合 e=0",
            "# e = 1",
            "",
            "# input = sys.stdin.readline",
            "# N, M = map(int, input().split())",
            "# T = Rerooting(N)",
            "# for _ in range(N-1):",
            "#     x, y = map(int, input().split())",
            "#     T.add_edge(x, y)",
            "",
            "# dp = T.rerooting(op=op, merge=merge, e=e, root=1)",
            "# print(*dp, sep=\"\\n\")",
        ],
        "description": "全方位木DPをするクラス",
    },
    "Manacher": {
        "prefix": "Manacher",
        "body": [
            "def Manacher(S):",
            "    c = 0",
            "    n = len(S)",
            "    R = [0] * n",
            "    for i in range(n):",
            "        l = c - (i-c)",
            "        if i + R[l] < c + R[c]:",
            "            R[i] = R[l]",
            "        else:",
            "            j = c + R[c]-i",
            "            while i-j >= 0 and i + j < n and S[i-j] == S[i+j]:",
            "                j += 1",
            "            R[i] = j",
            "            c = i",
            "    return R",
            "",
            "",
            "# https://snuke.hatenablog.com/entry/2014/12/02/235837",
            "print(Manacher(\"abaaababa\"))  # => [1, 2, 1, 4, 1, 2, 3, 2, 1]",
            "# 計算量はO(N)で、文字列の長さに比例する",
        ],
        "description": ""
    },
    "Rerooting2": {
        "prefix": "Rerooting2",
        "body": [
            "class RootedTree:",
            "    def __init__(self, _G: list, _root: int, lp=False, lca=False):",
            "        self._n = len(_G)",
            "        self._G = _G",
            "        self._root = _root",
            "        self._height = -1",
            "        self._toposo = []",
            "        self._dist = []",
            "        self._descendant_num = []",
            "        self._leaf = []",
            "        self._leaf_num = []",
            "        self._parents = []",
            "        self._diameter = -1",
            "        self._bipartite_graph = []",
            "        self._lp = lp",
            "        self._lca = lca",
            "        self._rank = []",
            "        K = 1",
            "        while 1 << K < self._n:",
            "            K += 1",
            "        self._K = K",
            "        self._doubling = [[-1]*self._n for _ in range(self._K)]",
            "        self._calc_dist_toposo()",
            "        if lp:",
            "            self._calc_leaf_parents()",
            "        if lca:",
            "            self._calc_doubling()",
            "",
            "    '''Return the number of vertex of self. / O(1)'''",
            "",
            "    def __len__(self) -> int:",
            "        return self._n",
            "",
            "    def __str__(self) -> str:",
            "        self._calc_leaf_parents()",
            "        ret = [\"<RootedTree> [\"]",
            "        ret.extend(",
            "            [f'  dist:{str(d).zfill(2)} - v:{str(i).zfill(2)} - p:{str(self._parents[i]).zfill(2)} - child:{sorted(self._leaf[i])}'",
            "             for i, d in sorted(enumerate(self._dist), key=lambda x: x[1])]",
            "        )",
            "        ret.append(']')",
            "        return '\\n'.join(ret)",
            "",
            "    def _calc_dist_toposo(self) -> None:",
            "        '''Calc dist and toposo. / O(N)'''",
            "        todo = [self._root]",
            "        self._dist = [-1] * self._n",
            "        self._rank = [-1] * self._n",
            "        self._dist[self._root] = 0",
            "        self._rank[self._root] = 0",
            "        self._toposo = [self._root]",
            "",
            "        while todo:",
            "            v = todo.pop()",
            "            d = self._dist[v]",
            "            r = self._rank[v]",
            "            for x, c in self._G[v]:",
            "                if self._dist[x] != -1:",
            "                    continue",
            "                self._dist[x] = d + c",
            "                self._rank[x] = r + 1",
            "                todo.append(x)",
            "                self._toposo.append(x)",
            "        return",
            "",
            "    def _calc_leaf_parents(self) -> None:",
            "        '''Calc child and parents. / O(N)'''",
            "        if self._leaf and self._leaf_num and self._parents:",
            "            return",
            "        self._leaf_num = [0] * self._n",
            "        self._leaf = [[] for _ in range(self._n)]",
            "        self._parents = [-1] * self._n",
            "",
            "        for v in self._toposo[::-1]:",
            "            for x, _ in self._G[v]:",
            "                if self._rank[x] < self._rank[v]:",
            "                    self._parents[v] = x",
            "                    continue",
            "                self._leaf[v].append(x)",
            "                self._leaf_num[v] += 1",
            "        return",
            "",
            "    '''Return dist. / O(N)'''",
            "",
            "    def get_dists(self) -> list:",
            "        return self._dist",
            "",
            "    '''Return toposo. / O(N)'''",
            "",
            "    def get_toposo(self) -> list:",
            "        return self._toposo",
            "",
            "    '''Return height. / O(N)'''",
            "",
            "    def get_height(self) -> int:",
            "        if self._height > -1:",
            "            return self._height",
            "        self._height = max(self._dist)",
            "        return self._height",
            "",
            "    '''Return descendant_num. / O(N)'''",
            "",
            "    def get_descendant_num(self) -> list:",
            "        if self._descendant_num:",
            "            return self._descendant_num",
            "        self._descendant_num = [1] * self._n",
            "",
            "        for v in self._toposo[::-1]:",
            "            for x, c in self._G[v]:",
            "                if self._dist[x] < self._dist[v]:",
            "                    continue",
            "                self._descendant_num[v] += self._descendant_num[x]",
            "",
            "        for i in range(self._n):",
            "            self._descendant_num[i] -= 1",
            "        return self._descendant_num",
            "",
            "    '''Return child / O(N)'''",
            "",
            "    def get_leaf(self) -> list:",
            "        if self._leaf:",
            "            return self._leaf",
            "        self._calc_leaf_parents()",
            "        return self._leaf",
            "",
            "    '''Return child_num. / O(N)'''",
            "",
            "    def get_leaf_num(self) -> list:",
            "        if self._leaf_num:",
            "            return self._leaf_num",
            "        self._calc_leaf_parents()",
            "        return self._leaf_num",
            "",
            "    '''Return parents. / O(N)'''",
            "",
            "    def get_parents(self) -> list:",
            "        if self._parents:",
            "            return self._parents",
            "        self._calc_leaf_parents()",
            "        return self._parents",
            "",
            "    '''Return diameter of tree. / O(N)'''",
            "",
            "    def get_diameter(self) -> int:",
            "        if self._diameter > -1:",
            "            return self._diameter",
            "        s = self._dist.index(self.get_height())",
            "        todo = [s]",
            "        ndist = [-1] * self._n",
            "        ndist[s] = 0",
            "        while todo:",
            "            v = todo.pop()",
            "            d = ndist[v]",
            "            for x, c in self._G[v]:",
            "                if ndist[x] != -1:",
            "                    continue",
            "                ndist[x] = d + c",
            "                todo.append(x)",
            "        self._diameter = max(ndist)",
            "        t = ndist.index(self._diameter)",
            "        # s - t",
            "        return self._diameter, s, t",
            "",
            "    '''Return [1 if root else 0]. / O(N)'''",
            "",
            "    def get_bipartite_graph(self) -> list:",
            "        if self._bipartite_graph:",
            "            return self._bipartite_graph",
            "        self._bipartite_graph = [-1] * self._n",
            "        self._bipartite_graph[self._root] = 1",
            "        todo = [self._root]",
            "        while todo:",
            "            v = todo.pop()",
            "            nc = 0 if self._bipartite_graph[v] else 1",
            "            for x, _ in self._G[v]:",
            "                if self._bipartite_graph[x] != -1:",
            "                    continue",
            "                self._bipartite_graph[x] = nc",
            "                todo.append(x)",
            "        return self._bipartite_graph",
            "",
            "    def _calc_doubling(self) -> None:",
            "        \"Calc doubling if self._lca. / O(NlogN)\"",
            "        if not self._parents:",
            "            self._calc_leaf_parents()",
            "        for i in range(self._n):",
            "            self._doubling[0][i] = self._parents[i]",
            "",
            "        for k in range(self._K-1):",
            "            for v in range(self._n):",
            "                if self._doubling[k][v] < 0:",
            "                    self._doubling[k+1][v] = -1",
            "                else:",
            "                    self._doubling[k +",
            "                                   1][v] = self._doubling[k][self._doubling[k][v]]",
            "        return",
            "",
            "    '''Return LCA of (u, v). / O(logN)'''",
            "",
            "    def get_lca(self, u: int, v: int) -> int:",
            "        assert self._lca",
            "        if self._rank[u] < self._rank[v]:",
            "            u, v = v, u",
            "        for k in range(self._K):",
            "            if ((self._rank[u] - self._rank[v]) >> k) & 1:",
            "                u = self._doubling[k][u]",
            "",
            "        if u == v:",
            "            return u",
            "        for k in range(self._K-1, -1, -1):",
            "            if self._doubling[k][u] != self._doubling[k][v]:",
            "                u = self._doubling[k][u]",
            "                v = self._doubling[k][v]",
            "        return self._doubling[0][u]",
            "",
            "    '''Return dist(u -- v). / O(logN)'''",
            "",
            "    def get_dist(self, u: int, v: int) -> int:",
            "        assert self._lca",
            "        return self._dist[u] + self._dist[v] - 2*self._dist[self.get_lca(u, v)] + 1",
            "",
            "    '''Return True if (a is on path(u - v)) else False. / O(logN)'''",
            "",
            "    def is_on_path(self, u: int, v: int, a: int) -> bool:",
            "        assert self._lca",
            "        return self.get_dist(u, a) + self.get_dist(a, v) == self.get_dist(u, v)",
            "",
            "    '''Return path (u -> v).'''",
            "",
            "    def get_path(self, u, v) -> list:",
            "        assert self._lca",
            "        self.get_parents()",
            "",
            "        def get_path_lca(u, v):",
            "            path = []",
            "            while u != v:",
            "                u = self._parents[u]",
            "                if u == v:",
            "                    break",
            "                path.append(u)",
            "            return path",
            "",
            "        lca = self.get_lca(u, v)",
            "        path = [u]",
            "        path.extend(get_path_lca(u, lca))",
            "        if u != lca and v != lca:",
            "            path.append(lca)",
            "        path.extend(get_path_lca(v, lca)[::-1])",
            "        path.append(v)",
            "        return path",
            "",
            "#  -----------------------  #",
            "# n = int(input())",
            "# G = [[] for _ in range(n)]",
            "# for _ in range(n-1):",
            "#   a, b, c = map(int, input().split())",
            "#   G[a].append((b, c))",
            "#   G[b].append((a, c))",
            "",
            "# tree = RootedTree(G, 0, lca=True)",
            "# x, s, t = tree.get_diameter()",
            "# path = tree.get_path(s, t)",
            "# print(x, len(path))",
            "# print(*path)",
        ],
        "description": ""
    },

    "Z_algo": {
        "prefix": "Z_algo",
        "scope": "python",
        "body": [
            "def Z_algorithm(s: str):",
            "    n = len(s)",
            "    Z_alg = [0] * n",
            "    Z_alg[0], i, j = n, 1, 0",
            "    while i < n:",
            "        while i + j < n and s[j] == s[i + j]:",
            "            j += 1",
            "        Z_alg[i] = j",
            "        if not j:",
            "            i += 1",
            "            continue",
            "        k = 1",
            "        while i + k < n and k + Z_alg[k] < j:",
            "            Z_alg[i + k], k = Z_alg[k], k + 1",
            "        i, j = i + k, j - k",
            "    return Z_alg",
        ],
        "description": ""
    },
    "RollingHash": {
        "prefix": "RollingHash",
        "scope": "python",
        "body": [
            "",
            "\"\"\"",
            "h1_1 = RollingHash(t1, 41, 10**9 + 9)",
            "rh2_2 = RollingHash(t2_2, 41, 10**9 + 9)",
            "",
            "for i in range(n+1):",
            "    h1_1 = rh1_1.get(0,i)",
            "get(0,3)とするとS[0:3](S[0],S[1],S[2])のハッシュ値を返す",
            "get(1,3)とするとS[1:3]のハッシュ値を返す",
            "閉区間",
            "\"\"\"",
            "",
            "",
            "class RollingHash():",
            "    def __init__(self, s, base, mod):",
            "        self.mod = mod",
            "        self.pw = pw = [1]*(len(s)+1)",
            "",
            "        l = len(s)",
            "        self.h = h = [0]*(l+1)",
            "",
            "        v = 0",
            "        for i in range(l):",
            "            h[i+1] = v = (v * base + ord(s[i])) % mod",
            "        v = 1",
            "        for i in range(l):",
            "            pw[i+1] = v = v * base % mod",
            "",
            "    def get(self, l, r):",
            "        return (self.h[r] - self.h[l] * self.pw[r-l]) % self.mod",
            "",
            "",
            "# rh = RollingHash(\"ababababab\", 10**9 + 7, 10**9 + 9)",
            "# print(rh.get(0, 3))",
            "",
        ],
        "description": ""
    },
    "maxflow": {
        "prefix": "maxflow",
        "body": [
            "# Ford-Fulkerson algorithm",
            "class FordFulkerson:",
            "    def __init__(self, N):",
            "        self.N = N",
            "        self.G = [[] for i in range(N)]",
            " ",
            "    def add_edge(self, fr, to, cap):",
            "        forward = [to, cap, None]",
            "        forward[2] = backward = [fr, 0, forward]",
            "        self.G[fr].append(forward)",
            "        self.G[to].append(backward)",
            " ",
            "    def add_multi_edge(self, v1, v2, cap1, cap2):",
            "        edge1 = [v2, cap1, None]",
            "        edge1[2] = edge2 = [v1, cap2, edge1]",
            "        self.G[v1].append(edge1)",
            "        self.G[v2].append(edge2)",
            " ",
            "    def dfs(self, v, t, f):",
            "        if v == t:",
            "            return f",
            "        used = self.used",
            "        used[v] = 1",
            "        for e in self.G[v]:",
            "            w, cap, rev = e",
            "            if cap and not used[w]:",
            "                d = self.dfs(w, t, min(f, cap))",
            "                if d:",
            "                    e[1] -= d",
            "                    rev[1] += d",
            "                    return d",
            "        return 0",
            " ",
            "    def flow(self, s, t):",
            "        flow = 0",
            "        f = INF = 10**9 + 7",
            "        N = self.N ",
            "        while f:",
            "            self.used = [0]*N",
            "            f = self.dfs(s, t, INF)",
            "            flow += f",
            "        return flow",
            "",
            "#N, M = map(int, readline().split())",
            "#ff = FordFulkerson(N)",
            "#for i in range(M):",
            "#    u, v, c = map(int, readline().split())",
            "#    ff.add_edge(u, v, c)",
        ],
        "description": "最大流　Ford-Fulkerson"
    },
     "maxflow2": {
        "prefix": "maxflow2",
        "body": [
            "class mf_graph:",
            "    def __init__(self, n=0):",
            "        self._n = n",
            "        self.g = [[] for _ in range(n)]",
            "        self.pos = []",
            "    ",
            "    def add_edge(self, frm, to, cap):",
            "        m = len(self.pos)",
            "        e1 = mf_graph._edge(to, cap)",
            "        e2 = mf_graph._edge(frm, 0)",
            "        e1.rev = e2",
            "        e2.rev = e1",
            "        self.pos.append(e1)",
            "        self.g[frm].append(e1)",
            "        self.g[to].append(e2)",
            "        return m",
            "    ",
            "    class edge:",
            "        def __init__(self, frm, to, cap, flow):",
            "            self.frm = frm",
            "            self.to = to",
            "            self.cap = cap",
            "            self.flow = flow",
            "        ",
            "        def __iter__(self):",
            "            yield self.frm",
            "            yield self.to",
            "            yield self.cap",
            "            yield self.flow",
            "    ",
            "    def get_edge(self, i):",
            "        e1 = self.pos[i]",
            "        e2 = e1.rev",
            "        return mf_graph.edge(e2.to, e1.to, e1.cap + e2.cap, e2.cap)",
            "    ",
            "    def edges(self):",
            "        return [self.get_edge(i) for i in range(len(self.pos))]",
            "    ",
            "    def change_edge(self, i, new_cap, new_flow):",
            "        e = self.pos[i]",
            "        e.cap = new_cap - new_flow",
            "        e.rev.cap = new_flow",
            "    ",
            "    def flow(self, s, t, flow_limit=0XFFFFFFFFFFFFFFF):",
            "        g = self.g",
            "        flow = 0",
            "        while flow < flow_limit:",
            "            level = [-1] * self._n",
            "            level[s] = 0",
            "            que = [None] * self._n",
            "            ql = 0",
            "            qr = 1",
            "            que[0] = s",
            "            unreached = True",
            "            while unreached and ql < qr:",
            "                v = que[ql]",
            "                ql += 1",
            "                for e in g[v]:",
            "                    to = e.to",
            "                    if e.cap and level[to] < 0:",
            "                        level[to] = level[v] + 1",
            "                        if to == t:",
            "                            unreached = False",
            "                            break",
            "                        que[qr] = to",
            "                        qr += 1",
            "            if unreached:",
            "                return flow",
            "            ptr = [len(es) for es in g]",
            "            stack = []",
            "            v = t",
            "            up = flow_limit - flow",
            "            res = 0",
            "            while True:",
            "                if v == s or not ptr[v]:",
            "                    if v == s:",
            "                        res = up",
            "                    while stack:",
            "                        tmp = res",
            "                        e, up, res = stack.pop()",
            "                        e.cap -= tmp",
            "                        e.rev.cap += tmp",
            "                        res += tmp",
            "                        if res < up:",
            "                            v = e.to",
            "                            break",
            "                    else:",
            "                        flow += res",
            "                        break",
            "                i = ptr[v]",
            "                while i:",
            "                    i -= 1",
            "                    e = g[v][i]",
            "                    if level[e.to] == level[v] - 1 and e.rev.cap:",
            "                        ptr[v] = i",
            "                        stack.append((e.rev, up, res))",
            "                        v = e.to",
            "                        up = min(up, e.rev.cap)",
            "                        res = 0",
            "                        break",
            "                else:",
            "                    ptr[v] = i",
            "        return flow",
            "    ",
            "    def min_cut(self, s):",
            "        visited = [False] * self._n",
            "        que = [None] * self._n",
            "        ql = 0",
            "        qr = 1",
            "        que[0] = s",
            "        visited[s] = True",
            "        while ql < qr:",
            "            p = que[ql]",
            "            ql += 1",
            "            for e in self.g[p]:",
            "                if e.cap and not visited[e.to]:",
            "                    visited[e.to] = True",
            "                    que[qr] = e.to",
            "                    qr += 1",
            "        return visited",
            "    ",
            "    class _edge:",
            "        def __init__(self, to, cap):",
            "            self.to = to",
            "            self.cap = cap",
            " ",
            "n, m = map(int, input().split())",
            "s = [input() for _ in range(n)]",
            "g = mf_graph(n * m + 2)",
            "for i in range(n):",
            "    for j in range(i % 2, m, 2):",
            "        if s[i][j] == '#':",
            "            continue",
            "        for di, dj in (1, 0), (0, 1), (-1, 0), (0, -1):",
            "            x, y = i + di, j + dj",
            "            if 0 <= x < n and 0 <= y < m and s[x][y] == '.':",
            "                g.add_edge(i * m + j, x * m + y, 1)",
            "for i in range(n):",
            "    for j in range(m):",
            "        if s[i][j] == '#':",
            "            continue",
            "        if (i + j) % 2 == 0:",
            "            g.add_edge(n * m, i * m + j, 1)",
            "        else:",
            "            g.add_edge(i * m + j, n * m + 1, 1)",
            "print(g.flow(n * m, n * m + 1))",
            "ans = [list(si) for si in s]",
            "for frm, to, cap, flow in g.edges():",
            "    if flow and frm < n * m and to < n * m:",
            "        i, j = frm // m, frm % m",
            "        x, y = to // m, to % m",
            "        if j == y:",
            "            if i > x:",
            "                i, j, x, y = x, y, i, j",
            "            ans[i][j], ans[x][y] = 'v^'",
            "        else:",
            "            if j > y:",
            "                i, j, x, y = x, y, i, j",
            "            ans[i][j], ans[x][y] = '><'",
            " ",
        ],
        "description": ""
    },
    "mincostflow": {
        "prefix": "mincostflow",
        "body": [
            "from heapq import heappush, heappop",
            "class MinCostFlow:",
            "    INF = 1 << 60",
            " ",
            "    def __init__(self, N):",
            "        self.N = N",
            "        self.G = [[] for i in range(N)]",
            "        self.route = []",
            " ",
            "    def add_edge(self, fr, to, cap, cost):",
            "        forward = [to, cap, cost, None]",
            "        backward = forward[3] = [fr, 0, -cost, forward]",
            "        self.G[fr].append(forward)",
            "        self.G[to].append(backward)",
            " ",
            "    def flow(self, s, t, f):",
            "        N = self.N",
            "        G = self.G",
            "        INF = MinCostFlow.INF",
            " ",
            "        res = 0",
            "        H = [0] * N",
            "        prv_v = [0] * N",
            "        prv_e = [None] * N",
            " ",
            "        d0 = [INF] * N",
            "        dist = [INF] * N",
            " ",
            "        while f:",
            "            dist[:] = d0",
            "            dist[s] = 0",
            "            que = [(0, s)]",
            " ",
            "            while que:",
            "                c, v = heappop(que)",
            "                if dist[v] < c:",
            "                    continue",
            "                r0 = dist[v] + H[v]",
            "                for e in G[v]:",
            "                    w, cap, cost, _ = e",
            "                    if cap > 0 and r0 + cost - H[w] < dist[w]:",
            "                        dist[w] = r = r0 + cost - H[w]",
            "                        prv_v[w] = v",
            "                        prv_e[w] = e",
            "                        heappush(que, (r, w))",
            "            if dist[t] == INF:",
            "                return None",
            " ",
            "            for i in range(N):",
            "                H[i] += dist[i]",
            " ",
            "            d = f",
            "            v = t",
            "            self.route.append([])",
            "            while v != s:",
            "                d = min(d, prv_e[v][1])",
            "                v = prv_v[v]",
            "                if v != s:",
            "                    self.route[-1].append(v)",
            "            f -= d",
            "            res += d * H[t]",
            "            v = t",
            "            while v != s:",
            "                e = prv_e[v]",
            "                e[1] -= d",
            "                e[3][1] += d",
            "                v = prv_v[v]",
            " ",
            "        return res",
            " ",
        ],
        "description": "最小費用流"
    },


}
